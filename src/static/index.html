<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>心拍数モニター</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #f0f8ff;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    #rate, #max-rate {
      width: 45%;
      padding: 10px;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .flex-container {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .button-container {
      text-align: center;
      margin-top: 20px;
    }
    button {
      font-size: 1.2em;
      padding: 10px 20px;
      margin: 10px;
      border: none;
      border-radius: 6px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #45a049;
    }
    .stop-button {
      background-color: #f44336;
    }
    .stop-button:hover {
      background-color: #e53935;
    }
    #turn-display-large {
      text-align: center;
      font-size: 3em;
      font-weight: bold;
      color: #333;
      margin-top: 20px;
    }
      .graph-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
  }
  .watch-graph {
    width: 45%;
    min-width: 300px;
  }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let intervalId = null;
    const maxHeartRates = JSON.parse(localStorage.getItem("maxHeartRates") || "{}");

    const MAX_POINTS = 30;

    let heartDataInterval = null;

    function startFetching() {
      if (intervalId !== null) return;
      intervalId = setInterval(() => {
        fetchHeartRate();
        refreshCurrentTurn();
      }, 1000);
      document.getElementById('status').innerText = '状態: 取得中';
      localStorage.setItem("fetchingStatus", "running");
    }


    function stopFetching() {
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
      document.getElementById('status').innerText = '状態: 停止';
      localStorage.setItem("fetchingStatus", "stopped");
    }

    async function fetchHeartRate() {
      try {
        const res = await fetch('/heart');
        const text = await res.text();
        let data = {};
        try {
          data = JSON.parse(text);
        } catch (e) {
          console.error('JSON parse error:', e);
          document.getElementById('rate').innerText = '取得エラー (形式不正)';
          return;
        }

        const rateContainer = document.getElementById('rate');
        const maxContainer = document.getElementById('max-rate');
        rateContainer.innerHTML = '';
        maxContainer.innerHTML = '';

        if (!data || Object.keys(data).length === 0) {
          rateContainer.innerText = 'データがありません';
          maxContainer.innerText = '最大心拍数を記録できません';
        } else {
          for (const [device_id, record] of Object.entries(data)) {
            const bpm = record.heartbeat;
            const div = document.createElement('div');
            const bpmText = (bpm !== undefined && bpm !== null) ? `${bpm}` : "--";
            div.innerText = `心拍数: ${bpmText} bpm (${device_id})`;
            div.style.fontSize = '1.5em';
            div.style.fontWeight = 'bold';
            rateContainer.appendChild(div);

          if (bpm !== undefined && bpm !== null) {
            if (!maxHeartRates[device_id] || bpm > maxHeartRates[device_id]) {
              maxHeartRates[device_id] = bpm;
              localStorage.setItem("maxHeartRates", JSON.stringify(maxHeartRates));
            }
          }
          }

          for (const [device_id, maxBpm] of Object.entries(maxHeartRates)) {
            const div = document.createElement('div');
            div.innerText = `最大心拍数: ${maxBpm} bpm (${device_id})`;
            div.style.fontSize = '1.5em';
            div.style.fontWeight = 'bold';
            maxContainer.appendChild(div);
          }
        }
      } catch (error) {
        document.getElementById('rate').innerText = '取得エラー';
        console.error('取得中にエラーが発生しました:', error);
      }
    }

    async function refreshGameStatus() {
      try {
        const res = await fetch('/status');
        const data = await res.json();
        document.getElementById('game-status').innerText = 'ゲーム状態: ' + (data.running ? '開始中' : '終了');
      } catch (error) {
        console.error(error);
        document.getElementById('game-status').innerText = 'ゲーム状態： 取得失敗';
      }
    }

async function startGame() {
  isGameRunning = true;
  await fetch("/start", { method: "POST" })
  .then(res => res.json())
  .then(data => {
    isGameRunning = true;  // これをここで！
    document.getElementById('game-status').innerText = 'ゲーム状態：開始';
    refreshGameStatus();
    setupGraphs();         // isGameRunningがtrueの状態で呼ぶ
    startPlotting();
  });
}

async function stopGame() {
  isGameRunning = false;
  try {
    const res = await fetch('/stop', { method: 'POST' });
    const data = await res.json();
    console.log('[JS] POST /stop ->', data);
    stopPlotting();  // ✅ 追加
    await refreshGameStatus();
    document.getElementById('csvBtn').style.display = 'inline-block';
    document.getElementById("heartRateDisplay").innerHTML = ''; // ✅ 心拍表示クリア
    alert('ゲームを終了しました');
  } catch (error) {
    console.error(error);
    alert('終了リクエスト失敗');
  }
}
    async function resetServer() {
      if (!confirm("本当にリセットしますか？全データを消去します。")) return;
      try {
        const res = await fetch('/reset', { method: 'POST' });
        const data = await res.json();
        localStorage.removeItem("maxHeartRates");
        document.getElementById('rate').innerHTML = '<p>読み込み中...</p>';
        document.getElementById('max-rate').innerHTML = '<p>最大心拍数を記録中...</p>';
        document.getElementById('status').innerText = '状態: 停止';
        await refreshGameStatus();
        await refreshCurrentTurn();
        await refreshClientList();
        alert('リセットが完了しました');
      } catch (error) {
        console.error(error);
        alert('リセットリクエスト失敗');
      }
    }

    async function refreshCurrentTurn() {
      try {
        const res = await fetch('/turn');
        const data = await res.json();
        let display = data.current_turn ? `watch ${data.current_turn.slice(-1)} のターンです` : '全員受付中';
        document.getElementById('current-turn').innerText = '今のターン: ' + display;
        document.getElementById('turn-display-large').innerText = display;
      } catch (error) {
        console.error(error);
        document.getElementById('current-turn').innerText = '今のターン: 取得失敗';
        document.getElementById('turn-display-large').innerText = '';
      }
    }

    async function refreshClientList() {
      const selector = document.getElementById("turnSelector");
      selector.innerHTML = "";
      try {
        const res = await fetch("/clients");
        const data = await res.json();
        document.getElementById('watch-count').innerText = `接続中のデバイス数: ${data.count}`;
        for (const ip in data.ids) {
          const id = data.ids[ip];
          const option = document.createElement("option");
          option.value = id;
          option.textContent = id;
          selector.appendChild(option);
        }
      } catch (e) {
        console.error(e);
        document.getElementById('watch-count').innerText = '接続中のデバイス数: 取得失敗';
      }
    }
    //ゲーム開始の処理
    function setTurn() {
      const selectedId = document.getElementById("turnSelector").value;
      fetch("/set_turn", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ current_turn: selectedId })
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message);
          refreshCurrentTurn();
        })
        .catch(err => console.error(err));
    }

    async function nextTurn() {
      try {
        const clientRes = await fetch("/clients");
        const turnRes = await fetch("/turn");
        const clients = await clientRes.json();
        const current = (await turnRes.json()).current_turn;
        const ids = Object.values(clients.ids).sort();
        const idx = ids.indexOf(current);
        const nextId = ids[(idx + 1) % ids.length];
        const res = await fetch("/set_turn", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ current_turn: nextId })
        });
        const result = await res.json();
        alert(result.message);
        refreshCurrentTurn();
      } catch (e) {
        console.error(e);
        alert("ターン変更に失敗しました");
      }
    }

    async function exportCSV() {
      if (!confirm("CSVファイルを保存しますか？")) return;
      try {
        const res = await fetch('/export_csv');
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "heart_rate_data.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
      } catch (error) {
        console.error(error);
        alert("CSV保存に失敗しました");
      }
    }


    function getRandomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`;
    }

 window.onload = () => {
  const prevStatus = localStorage.getItem("fetchingStatus");
  if (prevStatus === "running") {
    startFetching();
  } else {
    document.getElementById('status').innerText = '状態: 停止';
  }

  refreshGameStatus();
  refreshCurrentTurn();
  refreshClientList();


  setupGraphs();
};

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    console.log("復帰: グラフ強制更新");
    fetchHeartData();       // 一回強制取得
    refreshCurrentTurn();   // ターン表示も同期
  }
});
  let fetchHeartDataIntervalId = null;

function startHeartDataLoop() {
  if (heartDataInterval) return;
  heartDataInterval = setInterval(fetchHeartData, 1000); // 1秒ごとにデータ取得
}

    document.addEventListener('keydown', async (event) => {
      if (event.key === 'Enter') {
        try {
          const turnRes = await fetch("/turn");
          const turnData = await turnRes.json();
          const currentTurnId = turnData.current_turn;
          if (!currentTurnId) return alert("現在のターンIDが取得できません");

          const res = await fetch("/next_turn", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ end_turn: currentTurnId })
          });

          const data = await res.json();
          if (res.ok) {
            alert(`ターン終了 → 次: ${data.next_turn}`);
            await refreshCurrentTurn();
          } else {
            alert("ターン終了失敗: " + (data.error || data.message));
          }
        } catch (e) {
          console.error(e);
          alert("エラーが発生しました");
        }
      }
    });

        // 仮のwatch IDリスト（実際はサーバーから取得する）
    let watchIds = [];
    let isGameRunning = false;

    const charts = {};        // watchIDごとのChartインスタンス
    const dataBuffers = {};   // watchIDごとの心拍数履歴（30件）

    // グラフ描画用 canvas 生成
function createGraph(watchId) {
  const container = document.getElementById("graph-area");
  const div = document.createElement("div");
  div.className = "watch-graph";
  div.innerHTML = `
    <h3>${watchId}</h3>
    <canvas id="chart-${watchId}" height="200"></canvas>
  `;
  container.appendChild(div);

  const ctx = document.getElementById(`chart-${watchId}`).getContext('2d');

  dataBuffers[watchId] = [];

  const chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: [], // 時間ラベルは更新関数で管理
    datasets: [{
      label: '心拍数',
      data: [],
      borderColor: 'red',
      borderWidth: 2,
      pointRadius: 0,
      tension: 0.3
    }]
  },
  options: {
    animation: false,
    responsive: true,
scales: {
  x: {
    type: 'linear',
    min: 0,
    max: 30,
    title: {
      display: true,
      text: '時間（秒）'
    },
    ticks: {
      stepSize: 5,
      callback: function(value) {
        return `${value}秒前`;
      }
    }
  },
  y: {
    min: 60,
    max: 120,
    title: {
      display: true,
      text: 'BPM'
    }
  }
}  }
});
  charts[watchId] = chart;
}
    // データ取得関数
async function fetchHeartData() {
  if (!isGameRunning) return;

  const response = await fetch('/get_heart_data');
  const data = await response.json();

  Object.entries(data).forEach(([watchId, records]) => {
  // ✅ 修正後
  if (!charts[watchId]) return;
  const chart = charts[watchId];
    const bpmData = records.map((r, i) => ({
      x: i,
      y: r.bpm
    }));

    chart.data.datasets[0].data = bpmData;
    chart.update();
  });
}


async function setupGraphs() {
  try {
    const res = await fetch('/clients');
    const data = await res.json();
    watchIds = Object.values(data.ids);

    const container = document.getElementById("graph-area");
    container.innerHTML = ""; // 初期化

    for (const watchId of watchIds) {
      createGraph(watchId);
    }
    fetchHeartData();
    // setInterval(fetchHeartData, 1000); // 毎秒取得
  } catch (err) {
    console.error("グラフ初期化失敗:", err);
  }
}

let plotInterval = null;

function startPlotting() {
  if (plotInterval) clearInterval(plotInterval);

  plotInterval = setInterval(async () => {
    if (!isGameRunning) return;

    const response = await fetch("/get_heart_data");
    const data = await response.json();

    const now = Date.now();
    const past30s = now - 30000;

    for (const watchId in data) {
      const chart = charts[watchId];
      if (!chart) continue;

      const filtered = data[watchId].filter(r => r.timestamp >= past30s);
      const baseTime = filtered.length > 0 ? filtered[0].timestamp : now;

      chart.data.labels = filtered.map(r => ((r.timestamp - baseTime) / 1000).toFixed(1));
      chart.data.datasets[0].data = filtered.map(r => r.heartbeat);

      chart.update();
    }
  }, 1000);
}

function updateChart(watchId, heartbeat, timestamp) {
  const dataset = charts[watchId].data.datasets[0];
  const labels = charts[watchId].data.labels;

  // データ追加
  dataset.data.push(heartbeat);
  labels.push("none"); // 時間ラベルはカスタムcallbackで描画されるため空文字でOK

  // 最大30件まで保持
  if (dataset.data.length > 30) {
    dataset.data.shift();
    labels.shift();
  }

  charts[watchId].update();
}
  </script>
</head>
<body>
  <h1>心拍数モニター</h1>
  <div id="turn-display-large"></div>
  <div id="current-turn" style="text-align:center; font-weight:bold; margin-bottom:10px;"></div>
  <div id="status" style="text-align:center; font-weight:bold; margin-bottom:10px;">状態: 未設定</div>
  <div id="game-status" style="text-align:center; font-weight:bold; margin-bottom:10px;"></div>
  <div id="watch-count" style="text-align:center; font-weight:bold; margin-bottom:10px;"></div>

  <div class="flex-container">
    <div id="rate"><p>読み込み中...</p></div>
    <div id="max-rate"><p>最大心拍数を記録中...</p></div>
  </div>

  <div class="button-container">
    <h3>ターン操作</h3>
    <select id="turnSelector"></select>
    <button onclick="setTurn()">この人のターンにする</button>
    <button onclick="nextTurn()" style="font-size: 1.5em; margin-top: 10px;">ターンエンド</button>
    <hr>
    <button onclick="startFetching()">取得開始</button>
    <button class="stop-button" onclick="stopFetching()">取得停止</button>
    <br>
    <button onclick="startGame()">ゲーム開始</button>
    <button class="stop-button" onclick="stopGame()">ゲーム終了</button>
    <button onclick="resetServer()" style="background-color: #2196F3;">リセット</button>
    <button onclick="exportCSV()" id="csvBtn" style="display: none; background-color: #9C27B0;">CSV保存</button>
     <h2>心拍数グラフ（30秒表示、リアルタイム更新）</h2>
  <div id="graph-area" class="graph-container"></div>
  </div>
</body>
</html>