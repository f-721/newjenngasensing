<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>å¿ƒæ‹æ•°ãƒ¢ãƒ‹ã‚¿ãƒ¼</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #f0f8ff;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    #rate, #max-rate {
      width: 45%;
      padding: 10px;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .flex-container {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .button-container {
      text-align: center;
      margin-top: 20px;
    }
    button {
      font-size: 1.2em;
      padding: 10px 20px;
      margin: 10px;
      border: none;
      border-radius: 6px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #45a049;
    }
    .stop-button {
      background-color: #f44336;
    }
    .stop-button:hover {
      background-color: #e53935;
    }
    #turn-display-large {
      text-align: center;
      font-size: 3em;
      font-weight: bold;
      color: #333;
      margin-top: 20px;
    }
      .graph-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
  }
  .watch-graph {
    width: 45%;
    min-width: 300px;
  }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let intervalId = null;
    const maxHeartRates = JSON.parse(localStorage.getItem("maxHeartRates") || "{}");

    const MAX_POINTS = 30;

    let heartDataInterval = null;

    function startFetching() {
      if (intervalId !== null) return;
      intervalId = setInterval(() => {
        fetchHeartRate();
        refreshCurrentTurn();
      }, 1000);
      document.getElementById('status').innerText = 'çŠ¶æ…‹: å–å¾—ä¸­';
      localStorage.setItem("fetchingStatus", "running");
    }


    function stopFetching() {
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
      document.getElementById('status').innerText = 'çŠ¶æ…‹: åœæ­¢';
      localStorage.setItem("fetchingStatus", "stopped");
    }

    async function fetchHeartRate() {
      try {
        const res = await fetch('/heart');
        const text = await res.text();
        let data = {};
        try {
          data = JSON.parse(text);
        } catch (e) {
          console.error('JSON parse error:', e);
          document.getElementById('rate').innerText = 'å–å¾—ã‚¨ãƒ©ãƒ¼ (å½¢å¼ä¸æ­£)';
          return;
        }

        const rateContainer = document.getElementById('rate');
        const maxContainer = document.getElementById('max-rate');
        rateContainer.innerHTML = '';
        maxContainer.innerHTML = '';

        if (!data || Object.keys(data).length === 0) {
          rateContainer.innerText = 'ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“';
          maxContainer.innerText = 'æœ€å¤§å¿ƒæ‹æ•°ã‚’è¨˜éŒ²ã§ãã¾ã›ã‚“';
        } else {
          for (const [device_id, record] of Object.entries(data)) {
            const bpm = record.heartbeat;
            const div = document.createElement('div');
            const bpmText = (bpm !== undefined && bpm !== null) ? `${bpm}` : "--";
            div.innerText = `å¿ƒæ‹æ•°: ${bpmText} bpm (${device_id})`;
            div.style.fontSize = '1.5em';
            div.style.fontWeight = 'bold';
            rateContainer.appendChild(div);

          if (bpm !== undefined && bpm !== null) {
            if (!maxHeartRates[device_id] || bpm > maxHeartRates[device_id]) {
              maxHeartRates[device_id] = bpm;
              localStorage.setItem("maxHeartRates", JSON.stringify(maxHeartRates));
            }
          }
          }

          for (const [device_id, maxBpm] of Object.entries(maxHeartRates)) {
            const div = document.createElement('div');
            div.innerText = `æœ€å¤§å¿ƒæ‹æ•°: ${maxBpm} bpm (${device_id})`;
            div.style.fontSize = '1.5em';
            div.style.fontWeight = 'bold';
            maxContainer.appendChild(div);
          }
        }
      } catch (error) {
        document.getElementById('rate').innerText = 'å–å¾—ã‚¨ãƒ©ãƒ¼';
        console.error('å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
      }
    }

    async function refreshGameStatus() {
      try {
        const res = await fetch('/status', { cache: "no-store" });
        const data = await res.json();
        console.log('[DEBUG] /status data:', data); // â† ãƒ‡ãƒãƒƒã‚°ç”¨
        document.getElementById('game-status').innerText = 'ã‚²ãƒ¼ãƒ çŠ¶æ…‹: ' + (data.running ? 'é–‹å§‹ä¸­' : 'çµ‚äº†');
      } catch (error) {
        console.error(error);
        document.getElementById('game-status').innerText = 'ã‚²ãƒ¼ãƒ çŠ¶æ…‹ï¼š å–å¾—å¤±æ•—';
      }
    }

async function startGame() {
  isGameRunning = true;
  await fetch("/start", { method: "POST" })
  .then(res => res.json())
  .then(data => {
    isGameRunning = true;  // ã“ã‚Œã‚’ã“ã“ã§ï¼
    document.getElementById('game-status').innerText = 'ã‚²ãƒ¼ãƒ çŠ¶æ…‹ï¼šé–‹å§‹';
    refreshGameStatus();
    setupGraphs();         // isGameRunningãŒtrueã®çŠ¶æ…‹ã§å‘¼ã¶
    startPlotting();
  });
}

async function stopGame() {
  isGameRunning = false;
  try {
    const res = await fetch('/stop', { method: 'POST' });
    const data = await res.json();
    console.log('[JS] POST /stop ->', data);

    if (typeof stopPlotting === "function") {
      stopPlotting();
    }
    stopFetching();        // âœ… ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚‚åœæ­¢ â† è¿½åŠ ï¼
    await refreshGameStatus();
    document.getElementById('csvBtn').style.display = 'inline-block';
     const heartEl = document.getElementById("heartRateDisplay");
    if (heartEl) {
      heartEl.innerHTML = '';
    }
    alert('ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã—ãŸ');
  } catch (error) {
    console.error(error);
    alert('çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¤±æ•—');
  }
}
    async function resetServer() {
      if (!confirm("æœ¬å½“ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿå…¨ãƒ‡ãƒ¼ã‚¿ã‚’æ¶ˆå»ã—ã¾ã™ã€‚")) return;
      try {
        const res = await fetch('/reset', { method: 'POST' });
        const data = await res.json();
        localStorage.removeItem("maxHeartRates");
        document.getElementById('rate').innerHTML = '<p>èª­ã¿è¾¼ã¿ä¸­...</p>';
        document.getElementById('max-rate').innerHTML = '<p>æœ€å¤§å¿ƒæ‹æ•°ã‚’è¨˜éŒ²ä¸­...</p>';
        document.getElementById('status').innerText = 'çŠ¶æ…‹: åœæ­¢';
        await refreshGameStatus();
        await refreshCurrentTurn();
        await refreshClientList();
        alert('ãƒªã‚»ãƒƒãƒˆãŒå®Œäº†ã—ã¾ã—ãŸ');
      } catch (error) {
        console.error(error);
        alert('ãƒªã‚»ãƒƒãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆå¤±æ•—');
      }
    }

    async function refreshCurrentTurn() {
      try {
        const res = await fetch('/turn');
        const data = await res.json();
        let display = data.current_turn ? `watch ${data.current_turn.slice(-1)} ã®ã‚¿ãƒ¼ãƒ³ã§ã™` : 'å…¨å“¡å—ä»˜ä¸­';
        document.getElementById('current-turn').innerText = 'ä»Šã®ã‚¿ãƒ¼ãƒ³: ' + display;
        document.getElementById('turn-display-large').innerText = display;
      } catch (error) {
        console.error(error);
        document.getElementById('current-turn').innerText = 'ä»Šã®ã‚¿ãƒ¼ãƒ³: å–å¾—å¤±æ•—';
        document.getElementById('turn-display-large').innerText = '';
      }
    }

    async function refreshClientList() {
      const selector = document.getElementById("turnSelector");
      selector.innerHTML = "";
      try {
        const res = await fetch("/clients");
        const data = await res.json();
        document.getElementById('watch-count').innerText = `æ¥ç¶šä¸­ã®ãƒ‡ãƒã‚¤ã‚¹æ•°: ${data.count}`;
        for (const ip in data.ids) {
          const id = data.ids[ip];
          const option = document.createElement("option");
          option.value = id;
          option.textContent = id;
          selector.appendChild(option);
        }
      } catch (e) {
        console.error(e);
        document.getElementById('watch-count').innerText = 'æ¥ç¶šä¸­ã®ãƒ‡ãƒã‚¤ã‚¹æ•°: å–å¾—å¤±æ•—';
      }
    }
    //ã‚²ãƒ¼ãƒ é–‹å§‹ã®å‡¦ç†
    function setTurn() {
      const selectedId = document.getElementById("turnSelector").value;
      fetch("/set_turn", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ current_turn: selectedId })
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message);
          refreshCurrentTurn();
        })
        .catch(err => console.error(err));
    }

    async function nextTurn() {
      try {
        const clientRes = await fetch("/clients");
        const turnRes = await fetch("/turn");
        const clients = await clientRes.json();
        const current = (await turnRes.json()).current_turn;
        const ids = Object.values(clients.ids).sort();
        const idx = ids.indexOf(current);
        const nextId = ids[(idx + 1) % ids.length];
        const res = await fetch("/set_turn", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ current_turn: nextId })
        });
        const result = await res.json();
        alert(result.message);
        refreshCurrentTurn();
      } catch (e) {
        console.error(e);
        alert("ã‚¿ãƒ¼ãƒ³å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    }

    async function exportCSV() {
      if (!confirm("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ")) return;
      try {
        const res = await fetch('/export_csv');
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "heart_rate_data.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
      } catch (error) {
        console.error(error);
        alert("CSVä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    }


    function getRandomColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`;
    }

window.onload = async () => {
  const prevStatus = localStorage.getItem("fetchingStatus");
  if (prevStatus === "running") {
    startFetching();
  } else {
    document.getElementById('status').innerText = 'çŠ¶æ…‹: åœæ­¢';
  }

  await refreshGameStatus();
  await refreshCurrentTurn();
  await refreshClientList();
  await setupGraphs();

  // ğŸ” çŠ¶æ…‹ã‚’å–å¾—ã—ã¦ã€ã‚²ãƒ¼ãƒ ä¸­ãªã‚‰ã‚°ãƒ©ãƒ•æç”»ã‚‚å†é–‹
  try {
    const res = await fetch('/status');
    const status = await res.json();
    if (status.running) {
      isGameRunning = true;
      startPlotting();
    }
  } catch (e) {
    console.error("ã‚²ãƒ¼ãƒ çŠ¶æ…‹å–å¾—å¤±æ•—", e);
  }
};

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    console.log("å¾©å¸°: ã‚°ãƒ©ãƒ•å¼·åˆ¶æ›´æ–°");
    fetchHeartData();       // ä¸€å›å¼·åˆ¶å–å¾—
    refreshCurrentTurn();   // ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã‚‚åŒæœŸ
  }
});
  let fetchHeartDataIntervalId = null;

function startHeartDataLoop() {
  if (heartDataInterval) return;
  heartDataInterval = setInterval(fetchHeartData, 1000); // 1ç§’ã”ã¨ã«ãƒ‡ãƒ¼ã‚¿å–å¾—
}

    document.addEventListener('keydown', async (event) => {
      if (event.key === 'Enter') {
        try {
          const turnRes = await fetch("/turn");
          const turnData = await turnRes.json();
          const currentTurnId = turnData.current_turn;
          if (!currentTurnId) return alert("ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³IDãŒå–å¾—ã§ãã¾ã›ã‚“");

          const res = await fetch("/next_turn", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ end_turn: currentTurnId })
          });

          const data = await res.json();
          if (res.ok) {
            alert(`ã‚¿ãƒ¼ãƒ³çµ‚äº† â†’ æ¬¡: ${data.next_turn}`);
            await refreshCurrentTurn();
          } else {
            alert("ã‚¿ãƒ¼ãƒ³çµ‚äº†å¤±æ•—: " + (data.error || data.message));
          }
        } catch (e) {
          console.error(e);
          alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
        }
      }
    });

        // ä»®ã®watch IDãƒªã‚¹ãƒˆï¼ˆå®Ÿéš›ã¯ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å–å¾—ã™ã‚‹ï¼‰
    let watchIds = [];
    let isGameRunning = false;

    const charts = {};        // watchIDã”ã¨ã®Chartã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    const dataBuffers = {};   // watchIDã”ã¨ã®å¿ƒæ‹æ•°å±¥æ­´ï¼ˆ30ä»¶ï¼‰

    // ã‚°ãƒ©ãƒ•æç”»ç”¨ canvas ç”Ÿæˆ
function createGraph(watchId) {
  const container = document.getElementById("graph-area");
  const div = document.createElement("div");
  div.className = "watch-graph";
  div.innerHTML = `
    <h3>${watchId}</h3>
    <canvas id="chart-${watchId}" height="200"></canvas>
  `;
  container.appendChild(div);

  const ctx = document.getElementById(`chart-${watchId}`).getContext('2d');

  dataBuffers[watchId] = [];

  const chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: [], // æ™‚é–“ãƒ©ãƒ™ãƒ«ã¯æ›´æ–°é–¢æ•°ã§ç®¡ç†
    datasets: [{
      label: 'å¿ƒæ‹æ•°',
      data: [],
      borderColor: 'red',
      borderWidth: 2,
      pointRadius: 0,
      tension: 0.3
    }]
  },
  options: {
    animation: false,
    responsive: true,
scales: {
  x: {
  type: 'linear',
  min: 0,
  max: 30,
  reverse: true, // â† ã“ã‚Œã‚’è¿½åŠ ï¼
  title: {
    display: true,
    text: 'æ™‚é–“ï¼ˆç§’ï¼‰'
  },
  ticks: {
    stepSize: 5,
    callback: function(value) {
      return `${value}ç§’å‰`;
    }
  }
},
  y: {
    min: 60,
    max: 120,
    title: {
      display: true,
      text: 'BPM'
    }
  }
}  }
});
  charts[watchId] = chart;
}
    // ãƒ‡ãƒ¼ã‚¿å–å¾—é–¢æ•°
async function fetchHeartData() {
  if (!isGameRunning) return;

  const response = await fetch('/get_heart_data');
  const data = await response.json();

  const now = Date.now();  // âœ… â† ã“ã‚ŒãŒæŠœã‘ã¦ã‚‹ã¨xè»¸ãŒå£Šã‚Œã‚‹ï¼

  Object.entries(data).forEach(([watchId, records]) => {
    if (!charts[watchId]) return;
    const chart = charts[watchId];

    const bpmData = records.map(r => ({
      x: ((now - r.timestamp) / 1000),
      y: r.heartbeat
    }));

    chart.data.datasets[0].data = bpmData;
    chart.update();
  });
}

async function setupGraphs() {
  try {
    const res = await fetch('/clients');
    const data = await res.json();
    watchIds = Object.values(data.ids);

    const container = document.getElementById("graph-area");
    container.innerHTML = ""; // åˆæœŸåŒ–

    for (const watchId of watchIds) {
      createGraph(watchId);
    }
    fetchHeartData();
    // setInterval(fetchHeartData, 1000); // æ¯ç§’å–å¾—
  } catch (err) {
    console.error("ã‚°ãƒ©ãƒ•åˆæœŸåŒ–å¤±æ•—:", err);
  }
}

let plotInterval = null;

function startPlotting() {
  if (plotInterval) clearInterval(plotInterval);

  plotInterval = setInterval(async () => {
    if (!isGameRunning) return;

    const response = await fetch("/get_heart_data");
    const data = await response.json();

    const now = Date.now();
    const past30s = now - 30000;

    for (const watchId in data) {
      const chart = charts[watchId];
      if (!chart) continue;

      const filtered = data[watchId].filter(r => r.timestamp >= past30s);
      const baseTime = filtered.length > 0 ? filtered[0].timestamp : now;

      chart.data.labels = filtered.map(r => ((now - r.timestamp) / 1000).toFixed(0)); // ç§’å‰ã§çµ±ä¸€
      chart.data.datasets[0].data = filtered.map(r => ({
        x: ((now - r.timestamp) / 1000),
        y: r.heartbeat
      }));

      chart.update();
    }
  }, 1000);
}

function stopPlotting() {
  if (plotInterval) {
    clearInterval(plotInterval);
    plotInterval = null;
  }
}
function updateChart(watchId, heartbeat, timestamp) {
  const dataset = charts[watchId].data.datasets[0];
  const labels = charts[watchId].data.labels;

  // ãƒ‡ãƒ¼ã‚¿è¿½åŠ 
  dataset.data.push(heartbeat);
  labels.push("none"); // æ™‚é–“ãƒ©ãƒ™ãƒ«ã¯ã‚«ã‚¹ã‚¿ãƒ callbackã§æç”»ã•ã‚Œã‚‹ãŸã‚ç©ºæ–‡å­—ã§OK

  // æœ€å¤§30ä»¶ã¾ã§ä¿æŒ
  if (dataset.data.length > 30) {
    dataset.data.shift();
    labels.shift();
  }

  charts[watchId].update();
}

// document.getElementById('reset-button').addEventListener('click', async () => {
//   if (confirm("æœ¬å½“ã«å…¨IDã‚’åˆæœŸåŒ–ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) {
//     try {
//       const response = await fetch('/reset', { method: 'POST' });
//       const result = await response.json();
//       if (result.status === 'ok') {
//         alert('åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ');
//         location.reload();  // çŠ¶æ…‹æ›´æ–°ã®ãŸã‚ãƒªãƒ­ãƒ¼ãƒ‰ï¼ˆä»»æ„ï¼‰
//       } else {
//         alert('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + result.message);
//       }
//     } catch (error) {
//       console.error('[ERROR] åˆæœŸåŒ–ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¤±æ•—:', error);
//       alert('é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
//     }
//   }
// });
  </script>
</head>
<body>
  <h1>å¿ƒæ‹æ•°ãƒ¢ãƒ‹ã‚¿ãƒ¼</h1>
  <div id="turn-display-large"></div>
  <div id="current-turn" style="text-align:center; font-weight:bold; margin-bottom:10px;"></div>
  <div id="status" style="text-align:center; font-weight:bold; margin-bottom:10px;">çŠ¶æ…‹: æœªè¨­å®š</div>
  <div id="game-status" style="text-align:center; font-weight:bold; margin-bottom:10px;"></div>
  <div id="watch-count" style="text-align:center; font-weight:bold; margin-bottom:10px;"></div>

  <div class="flex-container">
    <div id="rate"><p>èª­ã¿è¾¼ã¿ä¸­...</p></div>
    <div id="max-rate"><p>æœ€å¤§å¿ƒæ‹æ•°ã‚’è¨˜éŒ²ä¸­...</p></div>
  </div>

  <div class="button-container">
    <h3>ã‚¿ãƒ¼ãƒ³æ“ä½œ</h3>
    <select id="turnSelector"></select>
    <button onclick="setTurn()">ã“ã®äººã®ã‚¿ãƒ¼ãƒ³ã«ã™ã‚‹</button>
    <button onclick="nextTurn()" style="font-size: 1.5em; margin-top: 10px;">ã‚¿ãƒ¼ãƒ³ã‚¨ãƒ³ãƒ‰</button>
    <hr>
    <button onclick="startFetching()">å–å¾—é–‹å§‹</button>
    <button class="stop-button" onclick="stopFetching()">å–å¾—åœæ­¢</button>
    <br>
    <button onclick="startGame()">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    <button class="stop-button" onclick="stopGame()">ã‚²ãƒ¼ãƒ çµ‚äº†</button>
    <button onclick="resetServer()" style="background-color: #2196F3;">ãƒªã‚»ãƒƒãƒˆ</button>
    <button onclick="exportCSV()" id="csvBtn" style="display: none; background-color: #9C27B0;">CSVä¿å­˜</button>
    <br>
    <!-- <button id="reset-button">IDåˆæœŸåŒ–</button> -->
     <h2>å¿ƒæ‹æ•°ã‚°ãƒ©ãƒ•ï¼ˆ30ç§’è¡¨ç¤ºã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ï¼‰</h2>
  <div id="graph-area" class="graph-container"></div>
  </div>
</body>
</html>